// Day 10 of advent of code 2025 - grol version
// https://adventofcode.com/2025/day/10

func readInput() {
    res := []
    for !eof() {
        line := read()
        if line == "" {
            continue
        }
        parts := split(line, " ")
        lights := []
        for l := parts[0][1:-1] {
            if l == "#" {
                lights += 1
            } else {
                lights += 0
            }
        }
        btns := []
        for b := parts[1:-1] {
            btn := []
            for i := split(b[1:-1], ",") {
                btn += int(i)
            }
            btns += [btn]
        }
        println("Machine lights", lights, "buttons", btns)
        res += {"l":lights, "b":btns}
    }
    return res
}

println("Part 1:")
machines := readInput()

for m := machines {
    println("Machine:", m)
}


func press(state, button) {
    // log("Pressing button:", button, "on state:", state)
    for i := button {
        state[i] = 1 - state[i]
    }
    // println("New state:", state)
    state
}

func solve(state, target, buttons) {
    queue := [{"state": state, "presses": 0, "nextIdx": 0}]
    numButtons := len(buttons)
    for len(queue) > 0 {
        current := queue[0]
        // println("Current state:", current.state, "presses:", current.presses, "nextIdx:", current.nextIdx)
        queue = queue[1:]  // pop front
        // Found solution - return immediately
        if current.state == target {
            println("Found solution with presses:", current.presses)
            return current.presses
        }
        // Only consider buttons from nextIdx onwards to avoid duplicate combinations
        // This ensures we only explore A,B,C and not B,A,C, C,A,B, etc.
        for bidx := current.nextIdx:numButtons {
            b := buttons[bidx]
            newState := press([]+current.state, b) // make a copy because of grol bug mutating arrays in place, sometimes
            queue += [{"state": newState, "presses": current.presses + 1, "nextIdx": bidx + 1}]
        }
    }
}

sum := 0
i:=1
for m := machines {
    lights := m.l
    btns := m.b
    println("Solving machine", i, "with lights", lights, "and buttons", btns)
    nlights := len(lights)
    state := [0]*nlights
    res = solve(state, lights, btns)
    println("Machine", i, "result:", res)
    sum += res
    i++
}

println("Part 1: Result:", sum)
